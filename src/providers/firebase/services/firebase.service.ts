/**
 * @fileoverview The FirebaseService class in TypeScript is used for handling file uploads, deletions, and generating
signed URLs using Firebase Storage. */
import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { initializeApp } from 'firebase/app';
import {
  deleteObject,
  getDownloadURL,
  getStorage,
  ref,
  uploadBytes,
} from 'firebase/storage';
import { v4 as uuidv4 } from 'uuid';

import { envNames, handlerException } from '@/config';

import { contentType } from '../constants';
import { IPath, ISetNameFile, IUploadFile } from '../interfaces';

@Injectable()
export class FirebaseService {
  constructor(private readonly configService: ConfigService) {}

  /**
   * The function `setNameFile` generates a unique file name based on the provided extension and path.
   * @param {ISetNameFile}  - The `setNameFile` function takes an object with two properties:
   * `extension` and `path`. The `extension` property is a string representing the file extension, and
   * the `path` property is a string representing the file path. The function generates a unique
   * identifier using `uuidv4()` and
   * @returns A string value is being returned, which is a concatenation of the `path`, a unique
   * identifier generated by `uuidv4()`, and the `extension`.
   */
  private setNameFile({ extension, path }: ISetNameFile): string {
    const data = `${path}${uuidv4()}.${extension}`;

    return data;
  }

  /**
   * The function `getSignedUrl` retrieves a signed URL for a file stored in Firebase Storage.
   * @param {IPath}  - The `getSignedUrl` function takes an object as a parameter with a property
   * `path` of type `string`. This function is responsible for generating a signed URL for downloading
   * a file from Firebase Storage using the provided `path`. If the `path` is not provided or is empty,
   * the function
   * @returns The `getSignedUrl` function returns a signed URL for downloading a file from Firebase
   * Storage. If the `path` parameter is not provided or is empty, an empty string is returned. If
   * there are any errors during the process of generating the signed URL, the function catches the
   * error and returns the result of the `handlerException` function with the error passed as an
   * argument.
   */
  async getSignedUrl({ path }: IPath) {
    if (!path) {
      return '';
    }
    try {
      const { app } = await this.firebaseConfig();
      const storage = getStorage(app);
      const storageRef = ref(storage, path);

      const url = await getDownloadURL(storageRef);
      return url;
    } catch (error) {
      return handlerException(error);
    }
  }

  /**
   * The function `uploadImages` uploads an image file to Firebase storage and returns a signed URL for
   * the uploaded image.
   * @param {IUploadFile}  - The `uploadImages` function is an asynchronous function that takes an
   * object with two properties as its parameter: `logo` and `path`. The `logo` property is expected to
   * be a file object with properties like `originalname` and `buffer`, while the `path` property is a
   * string
   * @returns The `uploadImages` function returns a signed URL for the uploaded image file after
   * successfully uploading it to Firebase Storage. If an error occurs during the process, the function
   * catches the error and returns the result of the `handlerException` function with the error passed
   * as an argument.
   */
  async uploadImages({ logo, path }: IUploadFile) {
    try {
      const { app } = await this.firebaseConfig();

      const storage = getStorage(app);

      const pathStorage = this.setNameFile({
        extension: logo.originalname.split('.')[1],
        path,
      });

      const storageRef = ref(storage, pathStorage);

      await uploadBytes(storageRef, logo.buffer, {
        contentType: contentType.jpeg,
      });

      return await this.getSignedUrl({ path: pathStorage });
    } catch (error) {
      return handlerException(error);
    }
  }

  /**
   * The function `deleteImage` deletes an image from Firebase Storage using the provided path.
   * @param {IPath}  - The `deleteImage` function is an asynchronous function that takes an object as a
   * parameter with a `path` property. The function uses Firebase Storage to delete an image located at
   * the specified path. If the deletion is successful, the function returns `true`. If an error occurs
   * during the deletion process,
   * @returns The `deleteImage` function is returning a boolean value. It returns `true` if the image
   * deletion is successful, and if there is an error during the deletion process, it returns the
   * result of the `handlerException` function which handles the error.
   */
  async deleteImage({ path }: IPath) {
    try {
      const { app } = await this.firebaseConfig();

      const storage = getStorage(app);

      const desertRef = ref(storage, path);

      await deleteObject(desertRef);

      return true;
    } catch (error) {
      return handlerException(error);
    }
  }

  /**
   * The function `firebaseConfig` initializes Firebase using configuration values retrieved from
   * environment variables.
   * @returns The `firebaseConfig` function is returning an object containing the initialized Firebase
   * app. The object has a key `app` which holds the initialized Firebase app.
   */
  private async firebaseConfig() {
    const firebaseConfig = {
      apiKey: this.configService.get<string>(envNames.firebase_apikey),
      authDomain: this.configService.get<string>(envNames.firebase_authdomain),
      projectId: this.configService.get<string>(envNames.firebase_projectid),
      storageBucket: this.configService.get<string>(
        envNames.firebase_storagebucket,
      ),
      messagingSenderId: this.configService.get<string>(
        envNames.firebase_messagingsenderid,
      ),
      appId: this.configService.get<string>(envNames.firebase_appid),
      measurementId: this.configService.get<string>(
        envNames.firebase_measurementid,
      ),
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);

    return { app };
  }
}
